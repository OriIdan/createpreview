#!/usr/bin/perl
# Create preview EPUB out of given EPUB
# Written by: Ori Idan <ori@heliconbooks.com>
# License: GPL v. 3 (http://www.gnu.org/copyleft/gpl.html)

# This script takes an EPUB file, unpacks it, removes files (chapters) 
# leaving a predefined number of chapters.
# It will add metadata according to http://www.idpf.org/epub/previews/
use XML::Parser;
use File::Basename;
use File::Copy qw(copy move);
use File::Path 'rmtree';
use Cwd;
use I18N::Langinfo qw(langinfo CODESET);
use Encode qw(decode);
binmode STDOUT, ":utf8";

$tmpbase = "staging";

use constant {
	NONE => 0,
	META => 100,
	MANIFEST => 200,
	SPINE => 300,
	DCTERMS => 101,
	NAV => 400,
	NAVOL => 401,
	NAVLI => 402,
	NAVLIA => 403,
};

$state = NONE;

if(($#ARGV + 1) < 2) {
	print "Create EPUB preview from given EPUB\n";
	print "usage: createpreview <epubfile> <num> <newfile> [acquisitionlink]\n";
	exit;
}

$codeset = langinfo(CODESET);
@ARGV = map { decode $codeset, $_ } @ARGV;

# Get command line arguments
$epubname = $ARGV[0];
$numchap = $ARGV[1];
$newfile = $ARGV[2];
$acqlink = $ARGV[3];

($basename, $oepbsdir, $ext) = fileparse($epubname, qr/\.[^.]*/);

$tempdir = "$tmpbase/$basename";

if(!mkdir($tempdir)) {
	$err = $!;
	if($err ne 'File exists') {
		print "Error: $!\n";
		die;
	}
}

# Extracting file to temporary directory
system("unzip -u $epubname -d $tempdir");

$container = "$tempdir/META-INF/container.xml";
if(! -e $container) {
	print "Error: $tempdir/META-INF/container.xml file does not exist\n";
	exit;
}

$cparse = new XML::Parser(Handlers => {Start => \&hdl_start });

$cparse->parsefile($container);

sub hdl_start {
	my ($p, $elt, %atts) = @_;
	if($elt eq 'rootfile') {
		$rootfile = $atts{'full-path'};
		print "#Root file: $tempdir/$rootfile\n";
		$rootfile =~ /(.*)\/.*/;
		$base = "$tempdir/$1";
		print "Base: $base\n";
		AnalyzeOPF();
	}
}

sub AnalyzeOPF {
	$parseopf = new XML::Parser(Handlers => {'Start' => \&opf_start, 
											 'End' => \&opf_end
											 });
	($n, $oebpsdir, $ext) = fileparse($rootfile);
	print "Processing OPF $tempdir/$rootfile\n";
	# Initialize remove list
	@remlist = ();
	$counter = 0;
	$parseopf->parsefile("$tempdir/$rootfile");
	# We now know which id's we are going to remove
	# We have to remove them from 3 places:
	#   1. OPF file
	#   2. NCX file (if exists)
	#   3. EPUB3 toc file (if exists)
	WriteOPF("$tempdir/$rootfile");
	# Handle EPUB3 toc file
	if($tocfile) {
		HandleTocFile($tocfile);
	}
	if($ncxfile) {
		HandleNCX($ncxfile);
	}
	# We are done now with the 3 files we need to change, now pack the EPUB file
	$cwd = getcwd;
	print "CWD: $cwd\n";
	chdir($tempdir);
	system("zip -0Xq tmp.zip mimetype");
	system("zip -Xr9Dq tmp.zip META-INF/");
	system("zip -Xr9Dq tmp.zip $rootfile");
	$parseopf = new XML::Parser(Handlers => {'Start' => \&opf_packstart});
	print "#Pack handleOPF $rootfile\n";
	($n, $oepbsdir, $ext) = fileparse($rootfile);
	$parseopf->parsefile("$rootfile");
	chdir($cwd);
	copy("$tempdir/tmp.zip", $newfile);
	rmtree([ $tempdir ]);
}

sub opf_packstart {
	my ($p, $elt, %atts) = @_;
	
	if($elt eq 'metadata') {
		$state = META;	
	}
	elsif($elt eq 'manifest') {
		$state = MANIFEST;
	}
	elsif($elt eq 'spine') {
		$state = SPINE;
	}
	if($state == META) {
		if($atts{'name'} eq 'cover') {
			$coverid = $atts{'content'};
		}
	}
	if($state == MANIFEST) {
		if($elt eq 'item') {
			$ref = $atts{'href'};
#			print "Adding file: $oepbsdir$ref\n";
			system("zip -Xr9Dq tmp.zip $oepbsdir$ref");
		}
	}
}

sub opf_start {
	my ($p, $elt, %atts) = @_;

	if($etl eq 'metadata') {
		$state = META;
	}
	if($elt eq 'manifest') {
		$state = MANIFEST;
	}
	if($elt eq 'spine') {
		$state = SPINE;
	}
	if($state == MANIFEST) {
		if($atts{'media-type'} =~ /dtbncx/) {
			$ncxfile = $atts{'href'};
			$ncxfile = "$base/$ncxfile";
			print "NCX: $ncxfile\n";
		}
		if($atts{'properties'} =~ /nav/) {
			$tocfile = $atts{'href'};
			$tocfile = "$base/$tocfile";
			print "TOC: $tocfile\n";
		}
	}
	if($state == SPINE) {
		if($elt eq 'itemref') {
			if(($counter <= $numchap) && ($atts{'linear'} ne 'no')) {
				$counter++;
			}
			if(($counter > $numchap) && ($atts{'linear'} ne 'no')) {
				push(@remlist, $atts{'idref'});
			}
		}
	}
}

sub opf_end {
	my ($p, $elt, %atts) = @_;

	if($elt eq 'metadata') {
		print TMPFILE "</metadata>\n";
		$state = NONE;
	}
	elsif($elt eq 'manifest') {
		print TMPFILE "</manifest>\n";
		$state = NONE;
	}
	elsif($elt eq 'spine') {
		print TMPFILE "</spine>\n";
		$state = NONE;
	}
	elsif($elt eq 'package') {
		print TMPFILE "</package>\n";
		$state = NONE;
	}
}

sub opf_wchar {
	my ($p, $str) = @_;
	
	print TMPFILE $str;
}

# Create new OPF
# It is assumed that @remlist contains list of id's to be removed
sub WriteOPF {
	$opf = shift;

	$tmpopf = "$opf.tmp";	
	open(IN, $opf);
	binmode IN, ":utf8";
	open(OUT, ">$tmpopf");
	binmode OUT, ":utf8";
	
	$state = 0;
	$noprint = 0;
	while(<IN>) {
		if($state == NONE) {
			if(/metadata/) {
				$state = META;
			}
			elsif(/manifest/) {
				$state = MANIFEST;
			}
			else {
				print OUT $_;
			}
		}
		if($state == META) {
			if(/<\/metadata/) {
				print OUT "<dc:type>preview</dc:type>\n";
				print OUT $_;
				$state = NONE;
			}
			else {
				print OUT $_;
			}
		}
		if($state == MANIFEST) {
			if(/spine/) {
				$state = SPINE;
				$noprint = 1;
			}
			$line = $_;
			$line =~ /id="(.*?)"/;
			$id = $1;
			if(grep $_ eq $id, @remlist) {
				$noprint = 1;
			}
			if($noprint == 0) {
				print OUT $line;
			}
			if($noprint && ($line =~ /\/>/)) {
				$noprint = 0;
			}
			
		}
		if($state == SPINE) {
			$line = $_;
			$line =~ /idref="(.*)"/;
			$id = $1;
			if(grep $_ eq $id, @remlist) {
				$noprint = 1;
			}
			else {
				print OUT $line;
				$noprint = 0;
			}
			if($line =~ /\/spine/) {
				$state = NONE;
			}
		}
	}
	close(OUT);
	close(IN);
	copy($tmpopf, $opf);
}

# Delete unneeded id's from TOC file
# It is assumed that same id's used in TOC file as used in OPF
# This is not a requirement of the standard therefore we are running a risk here.
# From my experience it is rare to see different id's in TOC file.
sub HandleTocFile {
	$tocfile = shift;
	
	$tmptoc = "$tocfile.tmp";
	open(IN, $tocfile);
	binmode IN, ":utf8";
	open(OUT, ">$tmptoc");
	binmode OUT, ":utf8";
	
	$state = NONE;
	while(<IN>) {
		if($state == NONE) {
			if(/<nav/) {
				$state = NAV;
			}
			print OUT $_;
		}
		elsif($state == NAV) {	# We are waiting for <ol>
			if(/ol/) {
				$state = NAVOL;
			}
			print OUT $_;
		}
		elsif($state == NAVOL) {	# Every tag now is <li> tag
			$line = $_;
			if($line =~ /li id="(.*?)"/) {
				$id = $1;
				if(grep $_ eq $id, @remlist) {
					$noprint = 1;
					print "id: $id\n";
				}
				if($noprint == 0) {
					print OUT $line;
				}
				if($line =~ /<\/li/) {
					$noprint = 0;
				}
			}
			if($line =~ /ol/) {
				$state = NONE;
				print OUT $line;
			}
		}
	}
	close(IN);
	close(OUT);
	copy($tmptoc, $tocfile);
}

# Delete unneeded id's from NCX file
# It is assumed that id's here are the same as used in OPF file
# Note that NCX structure is much more complicated then TOC file structure
sub HandleNCX {
	$ncxfile = shift;
	
	$tmpncx = "$ncxfile.tmp";
	open(IN, $ncxfile);
	binmode IN, ":utf8";
	open(OUT, ">$tmpncx");
	binmode OUT, ":utf8";

	$state = NONE;
	$po = 1;	# We handle play order no matter what is written in NCX file
	while(<IN>) {
		if($state == NONE) {
			if(/<navmap/i) {
				$state = NAV;
			}
			print OUT $_;
		}
		elsif($state == NAV) {
			$line = $_;
			if(/<navPoint.*id="(.*?)"/i) {
				$id = $1;
				if(grep $_ eq $id, @remlist) {
					$noprint = 1;
				}
				if($noprint == 0) {
					print OUT "<navPoint class=\"chapter\" id=\"$id\" playOrder=\"$po\">\n";
					$po++;
				}
			}
			elsif($noprint == 0) {
				print OUT $line;
			}
			if(/<\/navPoint/i) {
				$noprint = 0;
			}
		}
	}
	close(IN);
	close(OUT);
	copy($tmpncx, $ncxfile);
}
